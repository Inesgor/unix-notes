#!/bin/sh  
#
#	STANDARD(?) UNIX NOTES 
#
# This is Unix Notes. An GPG encrypted notes system designed for privacy
#
# The idea came from 'pass' the standard unix password manager

# VARIABLES
VERSION=1.0
#NOTES_UMASK='077'
NOTESDIR="${HOME}/.notes"
CONFIGFILE="${NOTESDIR}/config"
INITIAL_NOTEBOOK="${NOTESDIR}/notes"
DEFAULT_POINTER="${NOTESDIR}/DEFAULT"
USE_POINTER="${NOTESDIR}/USE"
GPGKEY=''
GPG_OPTS="--quiet --yes --compress-algo=none --no-encrypt-to" 
GPG="gpg"
SHREDCMD="rm"
EDITOR="${EDITOR:-vi}"
#SHREDCMD="shred"

#
# initialize notes system
#

cmd_init (){		# setup directories and GPG key  to be used

	umask "${NOTES_UMASK:-077}"

	if [ ! -d "$NOTESDIR" ]; then
		echo Creating notes directory:  $NOTESDIR
		mkdir $NOTESDIR
	fi

	create_config

	echo making default notebook \'${INITIAL_NOTEBOOK}\' 
	if [ ! -d "$INITIAL_NOTEBOOK" ]; then
		mkdir $INITIAL_NOTEBOOK
		echo Your default notebook $INITIAL_NOTEBOOK has been created you may now create notes
        # point to INITIAL_NOTEBOOK with DEFAULT_POINTER and USE_POINTER
		if [ ! -f "$DEFAULT_POINTER" ] ; then
			ln -s "`basename $INITIAL_NOTEBOOK`" "$DEFAULT_POINTER" 
		fi
		if [ ! -f "$USE_POINTER" ] ; then
			ln -s "`basename $INITIAL_NOTEBOOK`" "$USE_POINTER" 
		fi
	fi
}

create_config () {
	touch $CONFIGFILE
	chmod 600 $CONFIGFILE

	echo You have the following private keys on your keyring
	gpg -K

    if [ "`gpg -K | wc -l`" = "0" ] ; then 
        echo No Private keys in keyring ... aborting
        exit 1
    fi 

	echo By DEFAULT we will use the first key found as the key for encrypting
	echo If this is NOT what is required please edit $NOTESDIR/config to
	echo reflect the recipient you wish to use 
	echo You will need to edit the KEY parameter and set it to the email 
	echo address of the key you wish to use

	KEY="`gpg -K  --with-colons | grep fpr | head -1 | tr -d 'fpr:::::::::' `"
	echo "KEY	$KEY" > $CONFIGFILE

	echo Default config written:
	cat  $CONFIGFILE
}

get_recipient () {
	KEY=`grep KEY $CONFIGFILE| sed s/^KEY// | tr -d [:blank:]`
}

get_gpg_keyid () {
    newkeyid="$1"
    echo newkeyid supplied $newkeyid

    if [ "$newkeyid" != "" ] ; then

        validate_gpg_keyid  $newkeyid

        echo valid gpg key $newkeyid
    else
        echo No key supplied:  
    fi

}

validate_gpg_keyid () {
    testkey="$1"
    keyids="/tmp/keyids.$$"

    gpg --list-secret-keys --with-colons --keyid-format short | grep sec | cut -d':' -f 5 > $keyids

    # test key character length = the last 16 (short) or the full 40 (long) are acceptable
    case ${#testkey} in
        16|40) 
            shortkey="`echo ${testkey} | tail -c 17`"
            if [ "`grep ${shortkey} ${keyids}`" = "0" ] ; then
                echo Invalid GPG keyid
                cat $keyids
                echo \n\n Type 'gpg -k <keyid> to find out more about key'
                rm $keyids
                exit 1
            else 
                echo Valid key $testkey
            fi
            ;;
        *)  
            echo Provided key is invalid: keys should be 16 or 40 characters
            echo Valid keys are ...
            cat $keyids
            echo \n\n Type 'gpg -k <keyid> to find out more about key'
            rm $keyids
            exit 1;;
    esac
}


#
# note functions
#

note_add () {
    filen="$@"
    notefile="${USE_POINTER}/`echo ${filen} | tr ' ' '_'`"
	
	if [ -f "$notefile.gpg" ] ; then
		echo File exists ... cannot create
	else
		get_recipient 

		touch "$notefile"

		# create temporary note file
		$EDITOR "$notefile"

		#aspell -c "$notefile"

		# encrypt note file
		$GPG -e -r $KEY $GPG_OPTS "$notefile"

		rm "$notefile"
	fi
}

note_import () {
	toimport="$@"
    pathname="`dirname ${toimport}`"
	notefile="`basename ${toimport}`"
    notefile="`echo ${notefile} | tr ' ' '_'`"

	get_recipient
	
	if [ -f "${toimport}" ] ; then 
		$GPG -e -r $KEY $GPG_OPTS -o  "${USE_POINTER}/${notefile}.gpg" "${notefile}" 
	fi
}

note_view () {
	notefile="$USE_POINTER/$@"

	get_recipient
	
	if [ -f "${notefile}" ]; then 
		gpg -d "${notefile}" | ${PAGER:-more} 
	elif [ -f "${notefile}.gpg" ]; then 
		gpg -d "${notefile}.gpg" | ${PAGER:-more}
	else 
		echo Note file does not exist
	fi
}

note_edit () {
    myoptions="`echo ${theoptions} | tr ' ' '_'`"
	notefile="$USE_POINTER/$@"
	decrypted="`echo ${notefile} | sed s/.gpg//`"
	
	get_recipient 

	echo $notefile
	echo $decrypted
	
	if [ -f "$notefile" ]; then 
		gpg -d -o "${decrypted}" "${notefile}" 
		${EDITOR} "${decrypted}" 
		$GPG -e -r $KEY $GPG_OPTS "${decrypted}"
		rm ${decrypted}
	elif [ -f "${notefile}.gpg" ]; then 
		gpg -d -o "${decrypted}"  "${notefile}.gpg" 
		${EDITOR} "${decrypted}" 
		$GPG -e -r $KEY $GPG_OPTS "${decrypted}"
		rm ${decrypted}
	else 
		echo Note file does not exist
	fi
}

note_list () {
	ls "${USE_POINTER}" | column | more 
}

note_delete () {
	notefile="$USE_POINTER/$@"
	
	if [ -f "$notefile" ]; then 
		rm -i "$notefile" 
	elif [ -f "${notefile}.gpg" ]; then 
		rm -i "${notefile}.gpg" 
	else 
		echo Note file does not exist
	fi
}

note_rename () {
	MVCP="$1"
	shift
	notefile="$USE_POINTER/$@"
	read -p "Please enter new name for note: "  newname
    newname="`echo ${newname} | tr ' ' '_'`"

	case $notefile in
		*gpg) skip;;
		*) notefile="${notefile}.gpg"
	esac 

	newnotefile="${USE_POINTER}/${newname}"
	case $newnotefile in
		*gpg) skip;;
		*) newnotefile="${newnotefile}.gpg"
	esac 

	case $MVCP in 
		"cp")	processing="copying ";;
		"mv")	processing="moving ";;
	esac

	if [ -f "$notefile" ] ; then
		echo $notefile exists .... $processing
		$MVCP  "$notefile" "$newnotefile"
	elif [ -f "${notefile}.gpg" ] ; then 
		echo $notefile exists .... $processing
		$MVCP   "$notefile" "$newnotefile"
	else
		echo Note $notefile does not exist, aborting...
	fi
}

#
# notebook functions
#

notebook_add () {
    notebookname="$@"
    new_notebook="${NOTESDIR}/`echo ${notebookname} | tr ' ' '_'`"

	if [ ! -d "$new_notebook" ] ; then
		mkdir "$new_notebook"
		chmod 700 "$new_notebook"
		echo Created new notebook called $new_notebook
	else
		echo Notebook exists ... cannot create
	fi
}

notebook_delete () {
	notebook="${NOTESDIR}/$@"
	if [ ! -d "${notebook}" ] ; then
		echo Error: Notebook \'$notebook\' does not exist
		exit 1
	else
		echo Deleting files from $notebook
		rm -if ${notebook}/*.gpg
		
		if [ $? = 0 ] ; then 
			rmdir "$notebook"
		else
			echo Deleting files aborted ... aborting deleting notebook $notebook
		fi
	fi
}

notebook_rename () {
	MVCP="$1"
	shift

	if [ "$MVCP" = "cp" ] ; then
		MVCP="cp -r "
	fi

	notebook="$NOTESDIR/$@"
	read -p "Please enter new name for note: "  newname
    newname="`echo ${newname} | tr ' ' '_'`"
	newnotebook="${NOTESDIR}/${newname}"

	case $MVCP in 
		"cp")	processing="copying ";;
		"mv")	processing="moving ";;
	esac

	if [ -d "$notebook" ] ; then
		echo $notebook exists .... $processing
		$MVCP  "$notebook" "$newnotebook"
	else
		echo Note $notebook does not exist, aborting...
	fi
}

notebook_list () {
	ls "${NOTESDIR}" | sed 's/DEFAULT//; s/USE//; s/config//' | column | more 
}

#
# OTHER COMMANDS
#

cmd_extension_or_show () {
	cmd_usage
}

cmd_usage () {
cat << ENDHELP

		Standard (?) Unix Notes system

GPG encrypted notes system for BSD and Linux systems

SYSTEM:

	notes init		    initialize notes system
	notes newkey		change GPG key 
	notes help		    show help
	notes version		show version
	notes show|ls|list	list notes in current notebook
    notes newkey email  change GPG key 

NOTES MANAGEMENT:

	notes find|search 			    find notes   [YET TO BE IMPLEMENTED]
	notes insert|add note_title		add a note
	notes view|cat   note_title		view a note
	notes import     file			import a text file as a note
	notes rename|mv  note_title		rename a note (will prompt for new name)
	notes copy|cp    note_title		copy a note (will prompt for new name)
	notes delete|rm  note_title		delete a note
	notes edit|ed    note_title		edit a note

NOTEBOOK MANAGEMENT:
	
	notebook list|ls		        list notebooks
	notebook default    notebook	change default notebook
	notebook use	    notebook	use a notebook (no notebook: use default)
	notebook add|insert notebook	add a notebook
	notebook rename|mv  notebook	rename a notebook (will prompt for new name)
	notebook copy|cp    notebook	copy a notebook (will prompt for new name)
	notebook delete|rm  notebook	delete a notebook
	
ENDHELP
}

cmd_version () {
	echo "Version $VERSION"
}

cmd_view () {
	myoptions="$@"
	if [ "$1" = "" ]; then
		echo No note specified on command line
		exit 1
	fi
	case $PROGRAM in 
		"notes") note_view $myoptions;;
		"notebook") cmd_usage;;
	esac
}

cmd_show () {
	myoptions="$@"
	case $PROGRAM in 
		"notes") note_list $myoptions;;
		"notebook") notebook_list $myoptions;;
	esac
}

cmd_find () {
	echo cmd_find
}

cmd_insert () {
	myoptions="$@"
	case $PROGRAM in 
		"notes")    note_add $myoptions;;
		"notebook") notebook_add $myoptions;;
	esac
}

cmd_import () {
	myoptions="$@"
	case $PROGRAM in 
		"notes")    note_import $myoptions;;
		"notebook") cmd_usage;;
	esac
}

cmd_generate () {
	echo cmd_generate not implemented yet
}

cmd_delete () {
	myoptions="$@"
	case $PROGRAM in 
		"notes")    note_delete $myoptions;;
		"notebook") notebook_delete $myoptions;;
	esac
}

cmd_edit () {
	myoptions="$@"
	case $PROGRAM in 
		"notes")    note_edit $myoptions;;
		"notebook") notebook_edit ${myoptions};;
	esac
}

cmd_copy_move () {
	myoptions="$@"
	case $PROGRAM in 
		"notes")    note_rename $myoptions;;
		"notebook") notebook_rename ${myoptions};;
	esac
}

cmd_grep () {
	echo grep
}

cmd_git () {
	echo git not implemented yet
}

cmd_default () {
    nb="$@"
    notebook="$NOTESDIR/$nb"

    if [ "$nb" = "" ]  ;then
        echo Default notebook = "`readlink -f $DEFAULT_POINTER`"
        exit 0
    fi
    if [ -d "$notebook" ] ; then
        echo target notebook exists
        unlink  "$DEFAULT_POINTER" 
        ln -sf "$nb" "$DEFAULT_POINTER" 
    else
        echo Cannot set default notebook to $notebook as it does not exist
    fi
}

cmd_use () {
    nb="$@"
    notebook="$NOTESDIR/$nb"

    if [ "$nb" = "" ]  ;then
        defaultnbval="`readlink -f $DEFAULT_POINTER`"
        defaultnb="`basename $DEFAULT_POINTER`"
        echo no notebook specified using default notebook
        unlink "$USE_POINTER"
        ln -s "`basename $defaultnbval`" "$USE_POINTER"
        exit 0 
    fi
    if [ -d "$notebook" ] ; then
        echo target notebook exists
        unlink  "$USE_POINTER" 
        ln -sf "$nb" "$USE_POINTER" 
    else
        echo Cannot use $notebook as $nb does not exist
    fi
}

cmd_newkey () {
    mynewkey="$1"

    if [ "$mynewkey" = "" ]; then
        echo No new key supplied
        echo There are the following private keys on your keyring
        gpg --list-secret-keys --with-colons --keyid-format short | grep sec | cut -d':' -f 5
        exit 1
    fi

	get_recipient
    get_gpg_keyid   $mynewkey

    # now recrypt files 
    find ~/.notes -name \*.gpg | sed s/.gpg// | \

        while read filen ; 
        do 
            echo $filen; 
            gpg -o "${filen}" --yes -d "${filen}.gpg" 
            gpg -r ${mynewkey} --yes -e "${filen}"  && ${SHREDCMD} "${filen}"
            
        done
   
    # replace key in config file
    sed -i s/^KEY.*$/KEY\\t${mynewkey}/   ${CONFIGFILE}
}


#########################
#                      	#
#	MAIN PROGRAM        #
#                       #
#########################

PROGRAM="`basename ${0##*/}`"
COMMAND="$1"

case "$1" in
        init) shift;                    cmd_init "$@" ;;
        default) shift;                 cmd_default "$@" ;;
        use) shift;                     cmd_use "$@" ;;
        newkey) shift;                  cmd_newkey "$@" ;;
        help|--help) shift;             cmd_usage "$@" ;;
        version|--version) shift;       cmd_version "$@" ;;
        show|ls|list) shift;            cmd_show "$@" ;;
        view|cat) shift;           	    cmd_view "$@" ;;
        find|search) shift;             cmd_find "$@" ;;
        grep) shift;                    cmd_grep "$@" ;;
        insert|add) shift;              cmd_insert "$@" ;;
        import) shift;              	cmd_import "$@" ;;
        edit|ed|-e) shift;              cmd_edit "$@" ;;
        generate) shift;                cmd_generate "$@" ;;
        delete|rm|remove) shift;        cmd_delete "$@" ;;
        rename|mv) shift;               cmd_copy_move "mv" "$@" ;;
        copy|cp) shift;                 cmd_copy_move "cp" "$@" ;;
        git) shift;                     cmd_git "$@" ;;
        *)                              cmd_extension_or_show "$@" ;;
esac
exit 0


